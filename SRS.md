需求分析说明书
版本：1.2
日期：2025年4月9日，星期三
目录：
1.	引言
1.1 目的
1.2 范围
1.3 目标用户与预期读者
1.4 定义与缩写
1.5 参考文献
2.	总体描述
2.1 产品视角
2.2 产品功能摘要
2.3 用户特征
2.4 运行环境
2.5 假设与依赖
3.	具体需求
3.1 功能性需求
3.2 非功能性需求
3.3 外部接口需求
1.	引言
1.1.	目的
本文档旨在定义Unity3D与C++融合开发的简单平台跳跃游戏（后称“本游戏”）的需求。核心目标为在3D空间中实现精准平台跳跃的趣味游戏体验。
1.2.	范围
1.2.1.	包含范围： 
系统采用前后端分离架构：
前端（Unity）负责用户输入捕捉、状态展示和渲染；
后端（C++）负责核心游戏逻辑、物理计算（或状态判定）、碰撞检测；
两者通过本地 UDP 协议进行通信。
实现基于键盘WASD和空格键的3D游戏人物控制系统，需要较高的精准与即时响应能力；
设计一个包含障碍与陷阱（如尖刺与深渊）的关卡，游戏人物触碰陷阱躲避不及时会导致角色爆炸并回到起点；
实现简单的关卡内拉杆，可改变关卡内部的结构或陷阱；
使用简约3D画风，确保障碍与平台可清晰分辨；
使用C++提高性能。
1.2.2.	不包含的范围：
自定义地图编辑器；
多关卡游玩（闯关模式）；
剧情或精美的立绘；
在线地图分享模块。
1.3.	目标用户与预期读者
1.3.1.	目标用户
有兴趣游玩I Wanna Maker类游戏的玩家；
具有良好耐心与心态的玩家。
1.3.2.	预期读者
开发的合作者；
测试者；
评估的老师和助教；
有兴趣对项目进行改进的开发者。
1.4.	定义与缩写
SRS：软件需求分析说明书.
C++：课程语言.
前端 (Frontend): 指使用Unity开发的客户端程序，负责用户交互和图形渲染.
后端 (Backend): 指使用C++开发的服务器端程序（本地），负责处理游戏核心逻辑和状态.
UDP (User Datagram Protocol): 一种网络通信协议，用于前后端之间的消息传输.
本地通信: 指前后端进程在同一台机器上运行并通信.
2.	总体描述
2.1.	产品视角
本游戏是一款独立的3D平台跳跃游戏，旨在将2D的I Wanna Maker游戏进化至3D空间。使用Unity3D进行三维构建。本游戏采用客户端-服务器（本地）模式实现。Unity 作为前端负责用户体验和视觉呈现，C++ 作为后端处理核心逻辑，通过本地 UDP 实现两者解耦.
2.2.	产品功能
3D角色控制: 提供精准的水平移动和跳跃控制.
障碍与挑战: 关卡中布满致命陷阱和障碍，需要玩家精确操作来规避.
环境互动: 允许玩家通过开关、拉杆等元素与游戏世界互动.
物理模拟: 使用Unity的物理引擎实现真实的跳跃感和碰撞效果.
视觉呈现: 采用简约清晰的3D视觉风格.
高难度体验: 游戏的核心是提供具有挑战性、可能令人“血压暴涨”的游戏体验.
2.3.	用户特征
具有良好耐心；
具备高超的游戏操作技巧；
具有类似游戏经验。
2.4.	运行环境
目标平台：初步决定面向Windows PC.
硬件：未测试，具体要求待定.
软件环境：Windows7或更新的系统.
2.5.	假设与依赖
假设开发人员初步掌握Unity/C++；
假设本地 UDP 通信的延迟和可靠性满足游戏实时性要求；
假设测试者与用户有标准PC输入设备；
前后端之间依赖本地UDP协议进行通信；
依赖操作系统提供稳定的本地UDP通信支持
依赖C++后端实现或集成物理计算/碰撞检测逻辑；
依赖Unity3D运行；
依赖C++编译器与Unity的集成机制。
依赖asio库
3.	具体需求
3.1.	功能性需求
FR01-水平移动：系统允许玩家使用WASD四个按键在水平面上进行移动。
FR01.FE：捕捉WASD按键状态，将消息发送至BE。
FR01.BE：接收消息，计算即时新位置，返回计算结果与更新状态。
FR01.FE.Update：接收后端发送的更新，对画面进行更新。
FR02-跳跃：系统允许玩家在地面时按下空格以进行跳跃。
FR03-精准控制：角色移动与加速度应经过调整与优化，确保良好“跟手感“。
FR04-障碍碰撞检测：系统能够检测角色与危险障碍物的碰撞。
FR04.BE：后端应根据游戏世界状态和物理/碰撞逻辑，检测玩家角色与危险障碍物的碰撞。
FR04.FE：根据返回消息更新画面。
FR05-死亡与重生：当FR04触发时，应判定角色死亡，并在检查点重生角色。
FR05.FE：若接受后端“死亡”消息，则触发死亡动画并更新画面与摄像机位置。
FR06-互动元素-开关-交互：角色位于开关附近时，应能通过某种方式与开关交互。
FR07-互动元素-开关-处理：FR06触发后，应按照既有逻辑对关卡地图进行改变。
FR08-关卡目标：地图内有一个门样式的出口，玩家达到后即视为通关。
FR.Proto.Define：必须定义清晰、版本化的前后端 UDP 通信协议，包括消息类型、数据格式。
FR.Proto.State：协议需包含游戏状态的关键信息更新格式。
FR.Proto.Input：协议需包含玩家输入的标准化消息格式。
FR.Proto.Event：协议需包含一次性事件的消息格式。
3.2.	非功能性需求
NFR01-帧率：游戏运行时应该维持画面流畅（帧率最低不低于30FPS）。
NFR02-端到端延迟：应当使用户输入到角色及画面响应的延迟尽可能低。
NFR03-清晰度：游戏内视觉效果呈现需要清晰，平台边缘和各类元素应清晰可辨。
NFR04-可靠性：游戏运行时应保持稳定，若遇错误先记录在日志中，优先保证游戏运行。
NFR05-游戏平衡及体验：游戏应提供高难但可玩的挑战，尽量在激发玩家斗志的条件下不令玩家抓狂。
NFR06-可维护性：C++以及Unity结构应良好，需要足够多的注释，便于双人合作开发，尤其是协议和接口部分。
NFR.Sync：前后端状态同步。需要定义状态同步的频率和策略。
3.3.	外部接口需求
3.3.1.	前端接口：（Unity）
3.3.1.1.	用户输入接口：
描述：FE使用Unity的输入系统获取用户硬件输入。
输入：标准PC键盘与鼠标，用于菜单控制与游戏操作；
（计划中：Xbox游戏控制器）；
HI.FE.Keyboard: 系统应能检测并区分WASD键的按下、持续按下和释放状态，用于移动意图。
HI.FE.Jump: 系统应能检测空格的单次按下事件。
HI.FE.InteractKey: 系统应能检测交互键F的单次按下事件。
HI.FE.MouseUI: 系统应能处理鼠标点击事件，用于与UI交互。
  数据流：捕捉到的输入状态被按照协议格式化，通过UDP发送到后端。
3.3.1.2.	后端通信接口：
描述：前端通过本地UDP与后端进行双向通信。前端作为UDP客户端，负责发送用户输入意图/请求，并接收来自后端的游戏状态更新和事件通知。
要求：
SI.FE.UDPSend：前端必须能够根据定义的通信协议（参考FR.Proto）将玩家输入意图（移动、跳跃、互动等）打包成UDP数据并发送到指定的后端地址和端口。
SI.FE.UDPRecv：前端必须能够监听指定的本地端口，接收来自后端的UDP数据报。
SI.FE.Deserial：前端必须能够根据通信协议反序列化接收到的UDP数据，解析出游戏状态信息。
SI.FE.StateUpdate：前端接收到后端发送的游戏状态后，必须相应地更新游戏世界中的视觉表现，包括：
     更新角色与其他物体的位置与状态；
     更新Animator组件；
     （可能）播放音频；
     更新用户UI，如死亡次数，时间等。
SI.FE.ErrorHandle：前端应能处理UDP通信可能出现的异常（如端口占用、发送/接收失败），并可能需要处理与后端连接丢失的情况（如超时未收到后端消息），向用户显示适当提示。
3.3.1.3.	Unity引擎接口
描述：前端依赖Unity引擎的核心功能来实现视觉和听觉呈现。
包括：
     渲染：使用Unity内置的渲染管线、材质、着色器、光照等。
     动画：使用Animator和动画切片来实现角色动画。
     物理：主要是视觉效果。比如角色死亡后散成粉状在出生点重新聚为原型。
     音频：使用音频片段播放声音效果。
      UI：使用Unity UI构建用户界面。
3.3.2.	后端库：（C++）
基于UDP的本地网络通信；
网络库：asio(Standalone)；
数据序列化：protocol buffers；
物理：自定义的逻辑，以改进手感；
通用库：C++标准库。
